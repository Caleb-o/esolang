# Author    : Caleb
# Date      : 12th Feb 2022
# Modified  : 12th Feb 2022

## TODO:
## std_to_lower : Convert uppercase characters to lowercase
## std_to_higher : Convert lowercase characters to uppercase


# Get the square root of a number
# Parameters 	: INT - value
# Return		: INT - result
proc std_sqrt(n : int) -> int {
	n 0 = n 1 = or if {
		n
	} else {
		1 n 2 / 0 bind | result, end, start |

		start end < loop {
			start end + 2 / bind | mid |
			mid mid * bind | sqr |

			sqr n = if {
				false
			} else {
				sqr n <= if {
					mid 1 + bind | start|
					mid bind | result |
				} else {
					mid 1 - bind | end |
				}

				start end <
			}
		}

		result
	}
}

# Get the square root of a number
# Parameters 	: FLOAT - value
# Return		: FLOAT - result
proc std_sqrt(n : float) -> float {
	n 0.0 = n 1.0 = or if {
		n
	} else {
		1.0 n 2.0 / 0.0 bind | result, end, start |

		start end < loop {
			start end + 2.0 / bind | mid |
			mid mid * bind | sqr |

			sqr n = if {
				false
			} else {
				sqr n <= if {
					mid 1.0 + bind | start|
					mid bind | result |
				} else {
					mid 1.0 - bind | end |
				}

				start end <
			}
		}

		result
	}
}

# Returns a conversion of degrees into radians
# Parameters 	: FLOAT - degrees
# Return		: FLOAT - result
proc std_deg_to_rad(degrees : float) -> float {
	3.14159 strict | PI |

	degrees
	PI 180 /
	*
}

# Returns a conversion of radians into degrees
# Parameters 	: FLOAT - radians
# Return		: FLOAT - result
proc std_rad_to_deg(radians : float) -> float {
	3.14159 strict | PI |

	radians
	180 PI /
	*
}

# The factorial function says to multiply all whole numbers from our chosen number down to 1
# Parameters 	: INT - factor
# Return		: INT - result
proc std_factorial(factor : int) -> int {
	factor factor factor bind | idx, current, result |

	result 0 = if {
		1 bind | result |
	}

	factor 1 > loop {
		current 1 - bind | current |
		current result * bind | result |
		idx 1 - bind | idx |
		idx 1 >
	}
	result
}

# Math power of
# Parameters	: INT, INT - base, power
# Return		: INT - result
proc std_pow(base, pow : int) -> int {
	base 0 bind | idx, result |

	# Loop to get the result of the power
	true loop {
		result base * bind | result |
		idx 1 + bind | idx |
		idx pow 1 - <
	}
	# Return the result
	result
}

# Math power of
# Parameters	: FLOAT, INT - base, power
# Return		: FLOAT - result
proc std_pow(base : float, pow : int) -> float {
	base 0 bind | idx, result |

	# Loop to get the result of the power
	true loop {
		result base * bind | result |
		idx 1 + bind | idx |
		idx pow 1 - <
	}
	# Return the result
	result
}

# Returns a the distance between two 1 dimensional points
# Parameters 	: FLOAT, FLOAT - point A + B
# Return		: FLOAT - result
proc std_dist1d(x, y : float) -> float {
	y x - bind | result |

	result 0.0 < if {
		result @flipf
	} else {
		result
	}
}

# Returns a the distance between two 1 dimensional points
# Parameters 	: FLOAT, FLOAT - point A + B
# Return		: FLOAT - result
proc std_dist2d(x1, y1, x2, y2 : float) -> float {
	2 2 x2 |!2| !std_pow x1 -
	|!2| !std_pow

	2 2 y2 |!2| !std_pow y1 -
	|!2| !std_pow

	+
	|!1| !std_sqrt
}

# Wraps the native @str_cmp and provides a boolean
# Parameters	: STRING, STRING - src1, src2
# Return		: BOOL - result
proc std_str_cmp(str_a, str_b : string) -> bool {
	str_a str_b @str_cmp
}

# Wraps the native @stoi and provides an integer
# Parameters	: STRING - src
# Return		: INT - value (0 default)
proc std_stoi(str : string) -> int {
	str @stoi bind | value | drop

	# Create a default int
	value true @kind_cmp if {
		# Drop both boolean values
		# true + false generated by a bad stoi
		# Return 0 as default
		2 @drop_n 0
	} else { 
		# Drop the true
		drop 
	}
}

# Wraps the native @stof and provides a float
# Parameters	: STRING - src
# Return		: FLOAT - value (0 default)
proc std_stof(str : string) -> float {
	str @stof bind | value | drop

	# Create a default float
	value true @kind_cmp if {
		# Drop both boolean values
		# true + false generated by a bad stof
		# Return 0 as default
		2 @drop_n 0.0
	} else { 
		# Drop the true
		drop 
	}
}