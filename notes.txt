Circular dependencies:

If we were to allow Circular dependencies, we would have to do a final step after 
the last parse. Here would would have to patch all proc_calls, since the symbol may
not exist at the time.

The problem:
If we call a procedure that doesn't exist in the file, but exists within another,
it will not be capable of resolving the ID. eg. Experimenting imports Fib, Fib imports
Experimenting. Since we parse Fib first, any call to Experimenting procedures will not
resolve because we haven't parsed it yet.

Solution #1:
Store procedures as an id_literal (or proc_id_literal) and take the index from there,
this will require some adjustments to proc_call/procedure_def() because we expect it
to be added as a definition immediately. We can make proc_id_literal a temporary buffer,
just so we can resolve definitions.


Tests:
There should be a test flag which allows parsing and running tests. A polymorphic Runner type should be
available, which can be switched out with the interpreter. All ops should become their own function in
the base runner (virtual, but not pure virtual), so we can have one definition of the function. The 
test runner would just be the Runner, with some new functions to run all tests and track success/failures.

Based on the defined virtual functions, the interpreter could just be the runner, with some slight modifications.